[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;
render_mode unshaded;

const float TWO_PI = 6.2831853071795;
const float PI = TWO_PI/2.0;

uniform vec2 aspect_ratio=vec2(1.0);

uniform vec2 origin=vec2(0);
uniform vec2 ant1_pos = vec2(0);
uniform float ant1_enabled=1.0;
uniform float ant1_amplitude:hint_range(0.0,1.0,0.1)=1.0;
uniform float ant1_phase:hint_range(-360.0,360,0.1)=0.0;

uniform vec2 ant2_pos=vec2(0);
uniform float ant2_enabled=1.0;
uniform float ant2_phase:hint_range(-360.0,360.0,0.1)=0.0;
uniform float ant2_amplitude:hint_range(0.0,1.0,0.1)=1.0;

uniform vec2 ant3_pos=vec2(0);
uniform float ant3_enabled=1.0;
uniform float ant3_phase:hint_range(-360.0,360.0,0.1)=0.0;
uniform float ant3_amplitude:hint_range(0.0,1.0,0.1)=1.0;

uniform vec2 ant4_pos=vec2(0);
uniform float ant4_enabled=1.0;
uniform float ant4_phase:hint_range(-360.0,360.0,0.1)=0.0;
uniform float ant4_amplitude:hint_range(0.0,1.0,0.1)=0.0;

uniform float timer;
uniform float freq=3.0;
uniform float carrier_freq=1.0;
uniform float zoom:hint_range(0.5,20)=1.0;
uniform float time_shift=0;
uniform bool overlay=false;
uniform bool hide_below_ground=false;
uniform bool phase_mode=false;

vec2 uv_to_world(vec2 value)
{
	vec2 offset=vec2(0.5, 0.5);
	return ((value-offset)*aspect_ratio*zoom+origin)*vec2(1,-1);
}

float intensity_from(vec2 antenna_position, vec2 field_position, float phase)
{
	if (hide_below_ground && field_position.y<0.0)
		return 0.0;
	
	float dist= distance(field_position, antenna_position);
	float intensity=sin(freq * dist * TWO_PI - radians(phase) - (timer)+time_shift);
	//intensity*=0.5;
	return intensity;
}

float phase_from(vec2 antenna_position, vec2 field_position, float phase_offset)
{
	float dist= distance(field_position, antenna_position);//length(direction);
	float phase=(freq * dist * TWO_PI - radians(phase_offset) - (timer)+time_shift);
	return phase;
}

vec2 phasor_from(vec2 antenna_position, vec2 field_position, float phase_offset)
{
	float phase=phase_from(antenna_position, field_position, phase_offset);
	return vec2(cos(phase), sin(phase));
}

vec4 hsv_to_rgb(float h, float s, float v, float a)
{
    vec3 RGB;
	h=clamp(h,0.0,1.0);
	s=clamp(s, 0.0, 1.0);
	v=clamp(v, 0.0, 1.0);
	a=clamp(a, 0.0, 1.0);
    if ( s != 0.0 ) {
       float var_h = h * 6.0;
       float var_i = floor(var_h);   // Or ... var_i = floor( var_h )
       float var_1 = v * (1.0 - s);
       float var_2 = v * (1.0 - s * (var_h-var_i));
       float var_3 = v * (1.0 - s * (1.0-(var_h-var_i)));
       if      (var_i == 0.0) { RGB = vec3(v, var_3, var_1); }
       else if (var_i == 1.0) { RGB = vec3(var_2, v, var_1); }
       else if (var_i == 2.0) { RGB = vec3(var_1, v, var_3); }
       else if (var_i == 3.0) { RGB = vec3(var_1, var_2, v); }
       else if (var_i == 4.0) { RGB = vec3(var_3, var_1, v); }
       else                 { RGB = vec3(v, var_1, var_2); }
   }
	RGB=clamp(RGB, vec3(0), vec3(1));
   return vec4(RGB,a);
}

float filled_circle(vec2 dot_pos, vec2 world_pos,float radius)
{
	vec2 position=dot_pos-world_pos;
	return 1.0-smoothstep(radius, radius + 0.001, dot(position, position) * 4.0);
}

float circle(vec2 center, vec2 world_pos, float radius, float thickness)
{
	thickness/=2.0;
	float dist=distance(center, world_pos);
	dist = min(dist, 2.0 * radius - dist);
	return smoothstep(radius-thickness, radius-thickness/2.0, dist);
}

void fragment(){
	vec2 world_pos = uv_to_world(UV.xy);
	float ant_enabled=ant1_enabled+ant2_enabled+ant3_enabled+ant4_enabled;

	float total_enabled=max(ant_enabled,1.75);
	float amp_share = 1.0/total_enabled;
	if (!phase_mode)
	{
		float ant1 = intensity_from(ant1_pos, world_pos, ant1_phase) * ant1_amplitude * ant1_enabled / total_enabled;
		float ant2 = intensity_from(ant2_pos, world_pos, ant2_phase) * ant2_amplitude * ant2_enabled / total_enabled;
		float ant3 = intensity_from(ant3_pos, world_pos, ant3_phase) * ant3_amplitude * ant3_enabled / total_enabled;
		float ant4 = intensity_from(ant4_pos, world_pos, ant4_phase) * ant4_amplitude * ant4_enabled / total_enabled;
		float total= ant1 + ant2 + ant3 + ant4;
		//	total=total/total_enabled;
		if (overlay)
			COLOR=vec4(-min(0,ant1)-min(0,ant2)-min(0,ant3)-min(0,ant4),0,
						max(0,ant1)+max(0,ant2)+max(0,ant3)+max(0,ant4),1);
		else
			COLOR = vec4(-total,step(0.999,abs(total)),total,1);


	}
	else
	{
		vec2 ant1=phasor_from(ant1_pos, world_pos, ant1_phase) * ant1_amplitude * ant1_enabled;
		vec2 ant2=phasor_from(ant2_pos, world_pos, ant2_phase) * ant2_amplitude * ant2_enabled;
		vec2 ant3=phasor_from(ant3_pos, world_pos, ant3_phase) * ant3_amplitude * ant3_enabled;
		vec2 ant4=phasor_from(ant4_pos, world_pos, ant4_phase) * ant4_amplitude * ant4_enabled;

		vec2 total_phasor=ant1 + ant2 + ant3 + ant4;
		float total_phase=atan(total_phasor.y,total_phasor.x) + TWO_PI;
		COLOR=hsv_to_rgb(mod(total_phase, TWO_PI)/ TWO_PI, 1.0, 1.0, length(total_phasor));
	}
//	COLOR=mix(COLOR,vec4(1,0,1,1),filled_circle(ant1_pos,uv_to_world(UV.xy),0.0001) * ant1_enabled);
//	COLOR=mix(COLOR,vec4(0,1,1,1),filled_circle(ant2_pos,uv_to_world(UV.xy),0.0001) * ant2_enabled);
//	COLOR=mix(COLOR,vec4(1,1,0,1),filled_circle(ant3_pos,uv_to_world(UV.xy),0.0001) * ant3_enabled);
//	COLOR=mix(COLOR,vec4(1,1,1,1),filled_circle(ant4_pos,uv_to_world(UV.xy),0.0001) * ant4_enabled);
//	COLOR=mix(COLOR,vec4(0,1,0,1), circle(vec2(0), world_pos, 5.0, 0.1));
}"
