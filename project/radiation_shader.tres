[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;
render_mode unshaded;

const float TWO_PI = 6.2831853071795;

uniform vec2 aspect_ratio=vec2(1.0);

uniform vec2 origin=vec2(0);
uniform vec2 ant1_pos = vec2(0);
uniform float ant1_enabled=1.0;
uniform float ant1_amplitude:hint_range(0.0,1.0,0.1)=1.0;
uniform float ant1_phase:hint_range(-360.0,360,0.1)=0.0;

uniform vec2 ant2_pos=vec2(0);
uniform float ant2_enabled=1.0;
uniform float ant2_phase:hint_range(-360.0,360.0,0.1)=0.0;
uniform float ant2_amplitude:hint_range(0.0,1.0,0.1)=1.0;

uniform vec2 ant3_pos=vec2(0);
uniform float ant3_enabled=1.0;
uniform float ant3_phase:hint_range(-360.0,360.0,0.1)=0.0;
uniform float ant3_amplitude:hint_range(0.0,1.0,0.1)=1.0;

uniform vec2 ant4_pos=vec2(0);
uniform float ant4_enabled=1.0;
uniform float ant4_phase:hint_range(-360.0,360.0,0.1)=0.0;
uniform float ant4_amplitude:hint_range(0.0,1.0,0.1)=0.0;

uniform float timer;
uniform float freq=3.0;
uniform float carrier_freq=1.0;
uniform float zoom:hint_range(0.5,20)=1.0;
uniform float time_shift=0;
uniform bool overlay=false;
uniform bool hide_below_ground=false;
uniform bool phase_mode=false;

vec2 uv_to_world(vec2 value)
{
	vec2 offset=vec2(0.5, 0.5);
	return ((value-offset)*aspect_ratio*zoom+origin)*vec2(1,-1);
}

float intensity_from(vec2 antenna_position, vec2 field_position, float phase)
{
	if (hide_below_ground && field_position.y<0.0)
		return 0.0;
	
	//vec2 direction=field_position - antenna_position;
	float dist= distance(field_position, antenna_position);//length(direction);
	float intensity=sin(freq * dist * TWO_PI - radians(phase) - (timer)+time_shift);
	//intensity*=0.5;
	return intensity;
}

float phase_from(vec2 antenna_position, vec2 field_position, float offset)
{
	vec2 direction = field_position - antenna_position;
	float phase = radians(offset) - mod(length(direction) * TWO_PI, TWO_PI);
	return phase;
}

float filled_circle(vec2 dot_pos, vec2 world_pos,float radius)
{
	vec2 position=dot_pos-world_pos;
	return 1.0-smoothstep(radius, radius + 0.001, dot(position, position) * 4.0);
}

float circle(vec2 center, vec2 world_pos, float radius, float thickness)
{
	thickness/=2.0;
	float dist=distance(center, world_pos);
	dist = min(dist, 2.0 * radius - dist);
	return smoothstep(radius-thickness, radius-thickness/2.0, dist);
}

void fragment(){
	vec2 world_pos = uv_to_world(UV.xy);
	float ant_enabled=ant1_enabled+ant2_enabled+ant3_enabled+ant4_enabled;

	float total_enabled=max(ant_enabled,1.75);
	float amp_share = 1.0/total_enabled;
	if (!phase_mode)
	{
		float ant1 = intensity_from(ant1_pos, world_pos, ant1_phase) * ant1_amplitude * ant1_enabled / total_enabled;
		float ant2 = intensity_from(ant2_pos, world_pos, ant2_phase) * ant2_amplitude * ant2_enabled / total_enabled;
		float ant3 = intensity_from(ant3_pos, world_pos, ant3_phase) * ant3_amplitude * ant3_enabled / total_enabled;
		float ant4 = intensity_from(ant4_pos, world_pos, ant4_phase) * ant4_amplitude * ant4_enabled / total_enabled;
		float total= ant1 + ant2 + ant3 + ant4;
		//	total=total/total_enabled;
		if (overlay)
			COLOR=vec4(-min(0,ant1)-min(0,ant2)-min(0,ant3)-min(0,ant4),0,
						max(0,ant1)+max(0,ant2)+max(0,ant3)+max(0,ant4),1);
		else
			COLOR = vec4(-total,step(0.999,abs(total)),total,1);
	}
	else
	{
		if (ant_enabled==1.0)
		{
			COLOR=vec4(0,0,1,1);
		}
		else
		{
			float phase1=phase_from(ant1_pos, world_pos, ant1_phase);
			vec2 phase1_vec=vec2(cos(phase1), sin(phase1)) * ant1_enabled;
			float phase2=phase_from(ant2_pos, world_pos, ant2_phase);
			vec2 phase2_vec=vec2(cos(phase2), sin(phase2)) * ant2_enabled;
			float phase3=phase_from(ant3_pos, world_pos, ant3_phase);
			vec2 phase3_vec=vec2(cos(phase3), sin(phase3)) * ant3_enabled;
			float phase4=phase_from(ant4_pos, world_pos, ant4_phase);
			vec2 phase4_vec=vec2(cos(phase4), sin(phase4)) * ant4_enabled;
			float phase_reference= phase_from(vec2(0,0), world_pos, 0.0);
			vec2 reference_vec= vec2(cos(phase_reference), sin(phase_reference));
			
			vec2 total_vec=phase1_vec+phase2_vec+phase3_vec+phase4_vec;
			
			float dott=dot(total_vec, reference_vec);
			COLOR=vec4(max(0, -dott), 0, max(0, dott), 1);
		}
	}
	COLOR=mix(COLOR,vec4(1,0,1,1),filled_circle(ant1_pos,uv_to_world(UV.xy),0.0001) * ant1_enabled);
	COLOR=mix(COLOR,vec4(0,1,1,1),filled_circle(ant2_pos,uv_to_world(UV.xy),0.0001) * ant2_enabled);
	COLOR=mix(COLOR,vec4(1,1,0,1),filled_circle(ant3_pos,uv_to_world(UV.xy),0.0001) * ant3_enabled);
	COLOR=mix(COLOR,vec4(1,1,1,1),filled_circle(ant4_pos,uv_to_world(UV.xy),0.0001) * ant4_enabled);
	COLOR=mix(COLOR,vec4(0,1,0,1), circle(vec2(0), world_pos, 5.0, 0.1));
}"
